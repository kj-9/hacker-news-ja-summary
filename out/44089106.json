{
  "comments_id": "44089106",
  "rank": 7,
  "title": "Writing a Self-Mutating x86_64 C Program (2013)",
  "link": "https://ephemeral.cx/2013/12/writing-a-self-mutating-x86_64-c-program/",
  "created_date": "2025-05-25T20:11:48.330392",
  "comments_summary": "この記事は、自己書き換えコードについて解説しています。\n\n## W^X の問題点\n\nOpenBSD の W^X (Write XOR Execute) の仕組みでは、書き込みと実行を同時に許可しないため、自己書き換えコードはそのままでは動作しません。通常は、新しいコードを書き込むページを読み書き可能として、その後、実行可能に変更する必要があります。ただし、変更を行うコードと変更されるコードが同じページにある場合は、問題が発生します。この問題に対する解決策として、同じ共有メモリを2回マップし、一方をR|W、もう一方をR|Xとして、一方の領域に書き込み、もう一方のミラーされたマッピングから実行する方法があります。\n\n## ランタイム最適化\n\n自己書き換えコードは、実行時の最適化を可能にする可能性があります。JIT コンパイルはその一例です。C プログラムなどのネイティブコードでも、自己書き換えによってパフォーマンスを向上させることができます。例えば、オーディオやビデオのデコード処理において、フレームサイズなどの半定数をクリティカルなループにハードコードすることで、パフォーマンスを改善できます。\n\n## その他\n\n記事のレイアウトが優れており、内容が理解しやすいという意見がありました。また、SIC-1というゲームで自己書き換えプログラムを書いた経験について共有がありました。\n\n## まとめ\n\n自己書き換えコードは、特定の条件下でパフォーマンス向上や動的な最適化を可能にする技術ですが、セキュリティ上の懸念やデバッグの難しさなどの課題もあります。OpenBSDのようなセキュリティを重視するOSでは、W^Xの制限により、特別な工夫が必要になります。"
}