{
  "comments_id": "45118585",
  "rank": 10,
  "title": "Poor man's bitemporal data system in SQLite and Clojure",
  "link": "https://www.evalapply.org/posts/poor-mans-time-oriented-data-system/index.html",
  "created_date": "2025-09-03T20:12:08.197258",
  "comments_summary": "この記事は、bitemporalityの概念、つまり「4月4日に入手可能なデータを使って、3月の損益を把握する」などの特定の時点でのデータの状態を追跡することについて述べています。\n\n## bitemporalityの概念とデータベース設計の課題\n\n*   bitemporalityは、特定の時点でのデータの状態を把握したい場合に非常に役立つ概念です。\n*   しかし、このようなクエリをサポートするデータベース設計は一般的ではありません。\n*   Clojureはbitemporalityの概念をサポートしていますが、最近では閉鎖的な空間になっていることが残念です。\n\n## 貧者のデータベースアプローチとSQLiteフォークの可能性\n\n*   SQLiteを使った貧者のデータベースアプローチが提案されています。\n*   TursoのDBSPベースのインクリメンタルビューメンテナンス機能が、このアプローチにどのように役立つか興味深いでしょう。\n*   筆者は自身のシステムを完成させ、データを通して実行し、そのパフォーマンスを評価したいと考えています。\n\n## イベントソーシングと変更追跡の重要性\n\n*   PostgreSQLでtstzrangeフィールドを使用してbitemporalシステムを実装した経験が共有されています。\n*   変更テーブルを使用して、データベースの変更前後の状態を追跡しています。\n*   データの品質が課題であり、より良い変更追跡システムと、データのクリーニング、消去、取り消しをサポートするツールが必要であることが強調されています。\n*   すべてをログとして扱うアプローチが推奨されており、イベントベースのシステムでドメインの更新や転送などのイベントを追跡することが提案されています。\n\n## 現在のデータベースと時間データベースの比較\n\n*   現在のデータベース（CRUDレコード）と時間データベース（ファクトログ）の違いが議論されています。\n*   現在のデータベースでは、CRUD操作をリアルタイムで監査ログに変換する必要がありますが、時間データベースでは、クエリ時に任意の時点のログからデータをピボットできます。\n*   時間データベースは、ディスクスペースが安価であることを利用して、複雑さとデータベース機能の間でより良いトレードオフを見つけることができます。\n*   時間データベースをモデル化する場合は、すべてのテーブルをファクトテーブルとして書き込み、通常のクエリには自動生成された「現在のビュー」バージョンを使用することが推奨されます。\n\n## まとめ\n\nこの記事では、bitemporalityの概念、そのデータベース設計における課題、およびさまざまな実装アプローチについて議論されています。イベントソーシングと変更追跡の重要性が強調され、現在のデータベースと時間データベースの違いが比較されています。また、SQLiteやPostgreSQLなどの具体的なデータベースシステムでの実装経験も共有されています。"
}