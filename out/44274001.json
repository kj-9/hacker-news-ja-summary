{
  "comments_id": "44274001",
  "rank": 9,
  "title": "SIMD-friendly algorithms for substring searching (2018)",
  "link": "http://0x80.pl/notesen/2016-11-28-simd-strfind.html",
  "created_date": "2025-06-14T20:11:57.745923",
  "comments_summary": "この記事は、文字列検索におけるSIMD（Single Instruction, Multiple Data）アルゴリズムの利用について議論しています。\n\n## SIMD文字列検索の実装と最適化\n- 複数の人がSIMDを使って文字列検索や分割のアルゴリズムを実装し、最適化を試みている。\n- haystackの長さが既知の場合やneedleが大きい場合には、Quick Searchなどのアルゴリズムを組み合わせることで性能向上が見込める。\n- muslのstrstrと比較して、SIMD最適化されたlibcではある程度の改善が見られる。\n- 文字列のサイズによって効率が変わるため、SIMDのセットアップコードが割に合うかどうかの閾値をハードウェアごとにベンチマークする必要がある。\n\n## 実装上の注意点と課題\n- SIMDアルゴリズムの実装では、アライメントされていないデータの扱い、境界条件の処理、針が空の場合の整数オーバーフローなど、UB（未定義動作）を引き起こす可能性がある。\n- 特に境界条件の処理は煩雑になりがちで、SIMD文字列検索の実装をためらう要因となる。\n- 理想化されたアルゴリズムは、境界チェックが誤っている、haystackの長さが8の倍数であることを前提としているなど、実際の実装には注意が必要。\n\n## 既存のライブラリとアルゴリズム\n- ripgrep（Rustの`regex`クレート経由）では、AVX2を使ったアプローチで文字列検索を高速化している。\n- `memchr`ライブラリでは、needleの頻度の低い2バイトを選択するヒューリスティックを用いており、Two-WayやGNU libcの`memmem`よりも高速。\n- C#でもIndexOfにSIMDが実装されている。\n\n## まとめ\nこの記事では、SIMDを使った文字列検索アルゴリズムの実装、最適化、および注意点について議論されました。実装者は、特定のユースケースに対してSIMDが本当に必要かどうかを慎重に検討し、既存のライブラリやアルゴリズムを参考にしながら、境界条件などの実装上の課題に注意する必要があります。"
}