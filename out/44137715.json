{
  "comments_id": "44137715",
  "rank": 1,
  "title": "Beating Google's kernelCTF PoW using AVX512",
  "link": "https://anemato.de/blog/kctf-vdf",
  "created_date": "2025-05-30T20:13:05.435755",
  "comments_summary": "この記事は、GoogleのKernelCTFで利用されているproof-of-workメカニズムを最適化するテクニックについて解説しています。\n\n## VDFと最適化\n- VDF（Verifiable Delay Function）である「sloth」は、計算に時間がかかることを証明するために使用されます。\n- 連鎖的な計算であるため、CPUやGPUのコア数を増やしても実行時間は短縮されません。\n- AVX512を利用した最適化RSA実装と同様に、大きな指数計算を行います。\n\n## CTFの競争とインセンティブ\n- CTFの競争要素が、最適な行動を阻害する可能性があるという意見があります。脆弱性を見つけても、提出の競争に勝つために戦略を最適化する必要があるためです。\n- 参加者がエクスプロイトを隠し持つ可能性があるため、複数スロットを設けることで競争を緩和する提案があります。\n\n## Linuxカーネルのセキュリティ\n- Linuxカーネルのセキュリティ神話に対する議論が活発です。脆弱性が常に存在するという意見や、Windowsと比較して攻撃対象としての魅力が低いという見方があります。\n- 一方で、AndroidのセキュリティはLinuxカーネルを大幅に改善しているとの意見もあります。\n\n## その他の提案や意見\n- CPUメーカーに対して、VDF計算を高速化する専用命令の追加を提案する人がいます。\n- 脆弱性の提出数を減らすための基準が、現実世界と乖離しているという指摘があります。\n- Googleが脆弱性の提出に対して厳格な予算管理を行っている背景が説明されています。\n\n## まとめ\nKernelCTFのproof-of-workメカニズムは、脆弱性提出の競争を促進する一方で、参加者の行動に影響を与える可能性があります。Linuxカーネルのセキュリティに関する議論も交わされ、その脆弱性の多さから、GoogleがAndroidの基盤としてLinuxカーネルを使用することに対する疑問も呈されています。"
}