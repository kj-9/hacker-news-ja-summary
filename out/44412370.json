{
  "comments_id": "44412370",
  "rank": 8,
  "title": "Bloom Filters by Example",
  "link": "https://llimllib.github.io/bloomfilter-tutorial/",
  "created_date": "2025-06-29T20:12:42.753954",
  "comments_summary": "Hacker Newsの記事は、Bloom Filterとそのアプリケーションに関するものです。\n\n## 小さなBloom Filterの最適化\n投機的に64ビットのBloom Filterを小さなセットに追加することで、多くのメンバーシップチェックを行う際に、Bloom Filterがうまく機能すると、非常に多くの作業を節約できる可能性があります。 Chromiumは、`querySelector()`、CSSバケットのプレフィルタリングハッシュルックアップ、特定のAria属性を探す際の要素のラピッドリジェクトなど、多くの場所でこれを使用しています。既知の要素を事前に把握し、挿入する要素が多すぎない場合、偽陽性のない理想的なフィルターを作成することもできます。\n\n## Bloom Filterの説明\nBloom Filter、セット、ハッシュテーブルを理解するために必要な概念の重複率は約95%です。セットは、キーのみを気にするメンバーシップテストに使用されるハッシュテーブルです。Bloom Filterは、多対1のハッシュが衝突によってキー空間を「圧縮」するという事実を利用したセットです。Bloom Filterを理解していれば、ランダム射影と局所性鋭敏型ハッシュの実装も理解できます。\n\n## Bloom Filterのユースケース\nスタートアップ時から検索したい単語のリストがわかっていて、プログラムの実行中に変更されない特定のユースケースがあります。完璧なハッシュが最適です。固定セットを検索する場合は、Ragelライブラリを見てください。コンパイル時の検索生成は非常に優れています。Cassandraの読み取りスパイクをデバッグしているときにBloom Filterを使用しました。各SSTableのBloom Filterはディスクをスキップすることを意味しますが、デフォルトのFPレートは0.1程度と高く、ほとんどの読み取りはキャッシュミスであるため、偽陽性は非常に良くありませんでした。メモリを少し増やしましたが、無駄な読み取りを減らしました。\n\n## 実装の容易さ\nBloom Filterを実際に理解せずに使用していました。32ビットのMurmurHash関数を使用してWikipediaの記事から実装することにし、そのシンプルさに驚きました。C++を使用している場合は、`std::vector`（またはC++23以降は`std::bitset`）を使用して、ビットを空間効率の良い方法で保存できます。\n\n## まとめ\nこのディスカッションでは、Bloom Filterの最適化、説明、ユースケース、および実装について説明しました。Bloom Filterを特定のユースケースで使用するときのトレードオフを理解することが重要です。"
}