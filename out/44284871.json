{
  "comments_id": "44284871",
  "rank": 6,
  "title": "Show HN: Zeekstd – Rust Implementation of the ZSTD Seekable Format",
  "link": "https://github.com/rorosen/zeekstd",
  "created_date": "2025-06-16T20:13:32.955087",
  "comments_summary": "rorosenがZstandardのシーク可能な形式のRust実装を共有しました。通常のzstd圧縮ファイルは単一のフレームで構成されているため、先頭から解凍を開始する必要があります。シーク可能な形式は、圧縮データを一連の独立したフレームに分割し、それぞれが個別に圧縮されるため、アーカイブの中間セクションの解凍では、zstdはアーカイブ全体ではなく、最大でフレームの価値のある追加データを解凍するだけで済みます。\n\n## シーク可能なZstandardの動機と実装\nrorosenは、大きなzstd圧縮ファイルの一時停止と再開されたダウンロードを可能にするためにシーク可能な形式に取り組み始めました。彼は最初にアップストリームで利用可能なC関数へのバインディングを作成して使用しましたが、すぐにセグメンテーション違反に遭遇し、関数が基本的なことしか許可していないことがわかりました。アップストリームの実装を詳しく調べたところ、現在非推奨になっているコアAPIの関数を使用しており、低レベルの(解凍)コンテキストへのアクセスを許可していないことに気づきました。彼は、これがPoC/デモ実装のように見え、zstdコアAPIと同じようには保守されていないと考えています。彼の場合、シーク可能な形式の完全な書き換えが必要なようだったので、zstd 1.4.0から利用可能な高度なzstd圧縮APIへのバインディングを使用して、Rustでゼロから実装することにしました。その結果、単一の依存関係ライブラリクレートと、通常のzstdツールに似たシーク可能な形式のCLIクレートが得られました。\n\n## ツールとサポート\nsimeonmiteffは、シーク可能なzstdを必要とするツールを構築するためにGoライブラリを使用しているが、形式に対するより広範なサポートがないことに少し不安を感じていました。彼がzeekと名付けたのは、「zstd」と「seek」の組み合わせですか？ncrucesは、シーク可能なzstdでファイルを圧縮するためのツールサポートは今日どうなっているのか疑問に思っています。既存のライブラリがあれば、圧縮データベースを透過的に読み取る(書き込みではない)SQLite VFSをGoドライバ用に簡単に作成できるはずですが、ツールサポートが不足していました。zstd CLIはいつそれをサポートするのでしょうか？\n\n## 技術的な詳細と最適化\nstu2010は、この分野で最も一般的なツールはbgzipであると述べています。各ファイルの最初のいくつかのチャンクで辞書をトレーニングし、その辞書をスキップ可能なフレームの先頭に埋め込むことを検討しましたか？チャンクサイズが2MBの場合、違いはほとんどありませんが、チャンクサイズが小さい場合は大きなメリットがある可能性があります。ikaweは、カスタム辞書はバニラの(シーク不可能な)zstdの機能であると指摘しています。彼が理解しているように、すべてのシーク可能なzstdは有効なzstdであるため、可能であるはずです。\n\n## シーク可能な形式の代替案\nthroebrifnrは、Gzには同様のことを行う--rsyncableオプションがあることを指摘しています。Scaevolusは、Rsyncableはさらに進んでおり、固定サイズのブロックを持つ代わりに、ブロックの分割点を決定論的にコンテンツに依存させていると説明しています。andrewaylettは、zstdにもrsyncableオプションがあることを共有しています。\n\n## まとめ\nこのスレッドは、rorosenによるZstandardシーク可能形式のRust実装の共有について議論しています。これにより、ユーザーは圧縮されたファイル内をシークして、ダウンロードを再開したり、大きなファイルを効率的に解凍したりできます。投稿者はその必要性と、zstdの公式実装の制限を克服する必要性について説明しています。ディスカッションでは、ツールのサポート、名前の選択、「rsyncable」のような代替アプローチと最適化について掘り下げています。また、シーク可能なZstandardの標準化と潜在的なデータ破損の問題についても触れられています。"
}