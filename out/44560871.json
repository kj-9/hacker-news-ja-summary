{
  "comments_id": "44560871",
  "rank": 5,
  "title": "Strategies for Fast Lexers",
  "link": "https://xnacly.me/posts/2025/fast-lexer-strategies/",
  "created_date": "2025-07-14T20:14:11.888899",
  "comments_summary": "この記事は、高速な字句解析器を構築するための戦略に関するものです。この記事では、メモ化による高速化、ジャンプテーブル、C言語での実装、`FILE*`を操作する字句解析器、SIMD、その他の最適化手法など、さまざまな手法について説明しています。\n\n## ベンチマークとパフォーマンス\n- メモ化による高速化は驚くべきものでした。\n- ハンドロールされたジャンプテーブルが大きな影響を与えていることを示すベンチマークはありますか？\n- あるアーキテクチャとベンチマークでは、コンパイルされたgotoの方が高速でした。\n- 現代のコンパイラは、大きなswitch文にジャンプテーブルを使用しないのでしょうか？\n- 8 Mloc/sに達することができました。\n\n## 言語と実装\n- これはC言語で書かれています。\n- これのいくつかは他の言語に翻訳されます。\n- Rust、Go、C、C++などでも、ジャンプテーブル、mmapping、遅延数値解析、アロケーションの最小化、文字列スライス、インターニング、インラインハッシュはすべて機能します。\n- ClickHouse SQL Lexerを見てみることをお勧めします。\n\n## 字句解析器の設計と最適化\n- 字句解析器を文字列ビューではなく、`FILE*`で動作させるのが好きです。\n- 字句解析中の「意思決定」を最小限に抑えるようにしてください。\n- gotoスレッドを検討したのは、キーワードの識別だけでした。\n- キーワードの識別には、gotoスレッドを使用することを検討しました。\n- 完全に高性能な字句解析器は、できるだけ遠くまでジャンプする必要があります。\n- バイト単位で操作するということは、パフォーマンスに厳しい制限があることを意味します。\n- タギングマスクを使用して、さまざまなタイプのアトムを区別しました。\n- 分岐予測フレンドリーな設計を使用しました。\n\n## その他\n- 字句解析がコンパイラの主要なパフォーマンスのボトルネックであるというのは、素晴らしい問題です。\n- 字句解析はボトルネックになることはありますか？\n- REPLの場合を除き、通常は「事前にファイル全体を読み込む」方が有利です。\n- 字句解析は、ほとんどの場合ボトルネックではありません。「読みやすい字句解析器の戦略」を見てみたいと思います。\n\n## まとめ\nこの記事では、高速な字句解析器を構築するためのさまざまな戦略について説明しました。これらの戦略には、メモ化、ジャンプテーブル、SIMD、その他の最適化手法の使用が含まれます。この記事では、字句解析がコンパイラの主要なパフォーマンスのボトルネックであるかどうかについても議論し、字句解析はボトルネックになることはほとんどないという結論に達しました。"
}