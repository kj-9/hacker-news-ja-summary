{
  "comments_id": "44951563",
  "rank": 7,
  "title": "Without the futex, it's futile",
  "link": "https://h4x0r.org/futex/",
  "created_date": "2025-08-19T20:13:23.061735",
  "comments_summary": "この記事は、現代の並行処理において重要な役割を果たす Futex（fast userspace mutex）について解説しています。The Art of Multiprocessor Programmingという書籍が、Futexについて十分にカバーしていない点を批判し、Futexの重要性と、現代のハードウェアにおける効率的なプリミティブの中核をなすことを強調しています。\n\n## Futexの仕組みと重要性\n\nFutexは、ユーザー空間での高速なmutex処理を可能にする仕組みであり、競合が発生しない場合にはシステムコールを回避できます。\nFutexは、ロックと待機を分離し、カーネルはロックの状態に関与せず、待機キューの管理と競合状態の検出のみを行います。\n\n## Futexの進化と課題\n\nFutexは、当初はシンプルなsyscallでしたが、条件変数や優先順位の継承などの機能が追加され、APIが複雑化しています。\nLinuxのfutex syscallは、多機能でありながら、価値の低い部分も含まれています。\nWindowsでは、Futexに類似したWaitOnAddressというAPIが導入されています。\n\n## Futexと他の同期プリミティブ\n\nBenaphoreは、Futexが登場する前に存在した同期プリミティブですが、Futexほど汎用性が高くありません。\nWaitForMultipleObjectsは、複数のカーネルオブジェクトを待機するWindowsのAPIであり、LinuxではFutex2で同様の機能が実現されています。\n\n## まとめ\n\nFutexは、現代の並行処理において重要な役割を果たすプリミティブであり、その仕組みを理解することは、効率的な並行処理プログラミングに不可欠です。Futexは、ユーザー空間での高速なmutex処理を可能にし、競合が発生しない場合にはシステムコールを回避できます。\nFutexのAPIは複雑化していますが、その概念は他のOSのプリミティブにも影響を与えており、並行処理の世界において重要な存在です。"
}