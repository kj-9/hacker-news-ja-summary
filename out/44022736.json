{
  "comments_id": "44022736",
  "rank": 10,
  "title": "Understanding the Go Scheduler",
  "link": "https://nghiant3223.github.io/2025/04/15/go-scheduler.html",
  "created_date": "2025-05-21T20:13:07.692484",
  "comments_summary": "Goのスケジューラに関するHacker Newsのコメントの要約です。\n\n## スケジューラ最適化の障壁\n\nGoのスケジューラは、多くの潜在的な最適化に対する大きな障害となる可能性があるという意見があります。低レベルの最適化を行いたい場合は、別の言語を使用する方が良いかもしれません。Goでは、goroutineが実行されているスレッドを制御したり、重要なgoroutineに優先順位を付けたりしたい場合があります。これは、Goが複雑さを軽減するためのトレードオフです。\n\nただし、`runtime`パッケージの`LockOSThread`を使用すると、この問題を回避できます。これは、goroutineを現在のスレッドに固定し、他のgoroutineがそれを使用できないようにします。OSスレッドごとに1つのgoroutineがあり、それらが作業を受信して実行するようにモデル化すると、それに近づくことができます。\n\n## スケジューラの設計\n\nGoのスケジューラは、goroutineという単純な抽象化で「うまくいく」ため、優れた設計であるという意見があります。\n\n## GOMAXPROCSの設定\n\nランタイムがcgroupによって制限されている場合は、`GOMAXPROCS`を設定する必要があります。CPUの使用量が制限されているcgroupで実行されているGoプログラムをプロファイリングしたところ、ランタイムが`GOMAXPROCS`を使用可能なコア数に設定していました。その結果、スケジューラがgoroutineを多数のプロセス間でバウンスさせていました。JREは、リソースが制限されたcgroupで実行されているかどうかを判断し、それに基づいて適切な決定を下しますが、Goにはそのような機能はありません。\n\n## まとめ\n\nGoのスケジューラは、最適化の障壁となる可能性がある一方で、優れた設計であり、多くの場合、適切に機能します。ただし、ランタイムがcgroupによって制限されている場合は、`GOMAXPROCS`を設定する必要があります。"
}